# 第2章 Spring中常用的设计模式

## 1 工厂模式

### 1.1 简单工厂模式

- 定义：Simple Factory Pattern，是指由一个工厂对象决定创建哪种产品的实例
- 特点：适用于工厂类负责创建的对象较少的场景，且客户端只需要传入工厂类的参数，对于如何创建对象不需要关心

### 1.2 工厂方法模式

- 定义：Factory Method Pattern，是指定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类，工厂方法模式让类的实例化推迟到子类中进行。
- 特点：用户只需要关心所需产品对应的工厂，无须关心创建细节，而且加入新的产品时符合开闭原则。

### 1.3 抽象工厂模式

- 定义：Abastract Factory Pattern，是指提供一个创建一系列相关或相互依赖对象的接口，无须指定它们的具体类。
- 特点：客户端（应用层）不依赖于产品类实例如何被创建、如何被实现细节，强调的是一系列相关的产品对象（属于同一产品族）一起使用创建对象需要大量重复的代码。需要提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。

## 2 单例模式

### 2.1 饿汉式单例模式

- 定义：在类加载的时候就立即初始化，并且创建单例对象，绝对线程安全。
- 优点：没有加任何锁，执行效率比较高，用户体验比懒汉式单例模式更好。
- 缺点：类加载的 候就初始化，不管用与不用都占着空间，浪费内存。

```java
public class HungrySingleton {
    // 先静态、后动态
    // 先属性、后方法
    // 先上后下
    private static final HungrySingleton hungrySingleton = new HungrySingleton();

    private HungrySingleton(){}

    public static HungrySingleton getInstance(){
        return  hungrySingleton;
    }
}
```

### 2.2 懒汉式单例模式

- 特点：被外部类调用的时候，内部类才会加载。

```java
public class LazyInnerClassSingleton {
    // 默认使用LazyInnerClassGeneral的时候，会先初始化内部类
    // 如果没使用的话，内部类是不加载的
    private LazyInnerClassSingleton(){
        if(LazyHolder.LAZY != null){
            throw new RuntimeException("不允许创建多个实例");
        }
    }

    // 每一个关键字都不是多余的
    // static是为了使单例的空间共享, 保证这个方法不会被重写/重载
    public static final LazyInnerClassSingleton getInstance(){
        // 在返回结果以前，一定会先加载内部类
        return LazyHolder.LAZY;
    }

    // 默认不加载
    private static class LazyHolder{
        private static final LazyInnerClassSingleton LAZY = new LazyInnerClassSingleton();
    }
}
```

### 2.3 枚举式单例模式
```java
// 通常在通用API中使用
public enum EnumSingleton {
    INSTANCE;
    private Object data;
    public Object getData() {
        return data;
    }
    public void setData(Object data) {
        this.data = data;
    }
    public static EnumSingleton getInstance(){
        return INSTANCE;
    }
}
```

### 2.4 容器式单例模式
```java
//Spring中的做法，就是用这种注册式单例
public class ContainerSingleton {
    private ContainerSingleton(){}
    private static Map<String,Object> ioc = new ConcurrentHashMap<String,Object>();
    public static Object getInstance(String className){
        synchronized (ioc) {
            if (!ioc.containsKey(className)) {
                Object obj = null;
                try {
                    obj = Class.forName(className).newInstance();
                    ioc.put(className, obj);
                } catch (Exception e) {
                    e.printStackTrace();
                }
                return obj;
            } else {
                return ioc.get(className);
            }
        }
    }
}
```

## 3 原型模式

- 定义：Prototype Pattern，是指原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。
- 适用场景：
    1. 类初始化消耗资源较多。
    2. 使用 new 生成一个对象需要非常烦琐的过程（数据准备、访问权限等）。
    3. 构造函数 较复杂。
    4. 在循环体中产生大量对象。
- 分类：浅克隆、深克隆

## 4 代理模式

- 定义：Proxy Pattern，是指为其他对象提供一种代理，以控制对这个对象的访问。
- 特点：保护目标对象，增强目标对象
- 分类：静态代理、动态代理
- 静态代理和动态代理的区别
    1. 静态代理只能通过手动完成代理操作，如果被代理类增加了新的方法，代理类需要同步增加，违背开闭原则
    2. 动态代理采用在运行时动态生成代码的方式，取消了对被代理类的扩展限制，遵循开闭原则
    3. 若动态代理要对目标类的增强逻辑进行扩展，结合策略模式，只需要新增策略，便可完成，无须修改代理类的代码
- 优点：
    1. 代理模式能将代理对象与真实被调用目标对象分离。
    2. 在一定程度上降低了系统的耦合性，扩展性好
    3. 可以起到保护目标对象的作用。
    4. 可以增强目标对象的功能
- 缺点：
    1. 造成系统设计中类的数量增加
    2. 在客户端和目标对象中增加一个代理对象，会导致请求处理速度变慢
    3. 增加系统的复杂度

## 5 委派模式

- 定义：Delegate Pattern，主要负责任务的调用和分配，可看作一种特殊情况下的静态的全权代理

## 6 策略模式

- 定义：Strategy Pattern，是指定义了算法家族并分别封装起来，让它们之间可以互相替换
- 适用场景
    1. 系统中有很多类，而它的区别仅仅在于行为不同
    2. 一个系统需要动态地在几种算法中选择一种
- 优点：
    1. 符合开闭原则。
    2. 可避免使用多重条件语句，如`if...else`语句、switch语句。
    3. 提高算法的保密性和安全性
- 缺点：
1. 客户端必须知道所有的策略，并且自行决定使用哪一个策略类。
2. 代码中会产生非常多的策略类，增加了代码的维护难度

## 7 模板方法模式

- 定义：Template Method Pattern，，是指定义一个算法的骨架，允许子类为一个或者多个步骤提供实现。
- 特点：使得子类可以在不改变算法结构的情况下，定义算法的某些步骤
- 适用场景：
1. 一次性实现一个算法的不变部分，并将可变的行为留给子类来实现
2. 各子类中公共的行为被提取出来，并集中到一个公共的父类中，从而避免代码重复
- 优点：
    1. 将相同处理逻辑的代码放到抽象父类中，可以提高代码的复用性。
    2. 不同的代码放到不同的子类中，通过对子类的扩展增加新的行为，可以提高代码的扩展性。
    3. 把不变的行为写在父类中，去除子类的重复代码，提供了一个很好的代码复用平台，符合开闭原则。
- 缺点：
    1. 每个抽象类都需要一个子类来实现，导致了类的数量增加。
    2. 类数量的增加间接地增加了系统的复杂性。
    3. 因为继承关系自身的缺点，如果父类添加新的抽象方法，所有子类都要改一遍。

## 8 适配器模式

- 定义：Adapter Pattern，是指将一个类的接口转换成用户期望的另一个接口，使原本接口不兼容的类可以一起工作。
- 优点：
    1. 能提高类的透明性和复用性，现有的类会被复用但不需要改变。
    2. 目标类和适配器类解耦，可以提高程序的扩展性。
    3. 在很多业务场景中符合开闭原则
- 特点：
1. 在适配器代码编写过程中，需要进行全面考虑 ，可能会增加系统的复杂性。
2. 增加了代码的阅读难度，降低了可读性，过多使用适配器会使系统的代码变得凌乱。

## 9 装饰者模式

- 定义：Decorator Pattern，是指在不改变原有对象的基础上，将功能附加到对象上，提供了比继承更有弹性的方案（扩展原有对象的功能）
- 适用场景：
    1. 扩展一个类的功能或给一个类添加附加职责。
    2. 动态给一个对象添加功能，这些功能可以再动态地撤销。
- 优点：
    1. 装饰者模式是继承的有力补充，且比继承灵活，可以在不改变原有对象的情况下动态地给一个对象扩展功能，即插即用
    2. 使用不同的装饰类及这些装饰类的排列组合，可以实现不同的效果。
    3. 完全符合开闭原则。
- 缺点：
    1. 会出现更多的代码、更多的类，增加程序的复杂性。
    2. 动态装饰时，多层装饰会更复杂。
- 装饰者模式与适配器模式比较

|      | 装饰者模式  | 适配器模式 |
| :----: | ----- | ---- |
| **形式** | 是一种非常特别的适配器模式，有层级关系 | 没有层级关系 |
| **定义** | 装饰者和被装饰者实现同一个接口，主要目的是扩展之后依然保留OOP关系 | 适配器和被适配者没有必然的联系，通常采用继承或代理的形式进行包装 |
| **关系** | 满足`is-a`关系  | 满足`has-a`关系 |
| **功能** | 注重覆盖、扩展  | 注重兼容、转换  |
| **设计** | 前置考虑 | 后置考虑 |

## 10 观察者模式

- 定义：Observer Pattern，定义了对象之间的一对多依赖，让多个观察者对象同时监听一个主体对象，当主体对象发生变化时，它的所有依赖者（观察者）都会收到通知并更新。
- 特点： 也叫做发布订阅模式，主要用于在关联行为之间建立一套触发机制
- 优点：
    1. 在观察者和被观察者之间建立了一个抽象的耦合
    2. 支持广播通信
- 缺点：
    1. 观察者之间有过多的细节依赖、时间消耗多，程序的复杂性更高
    2. 使用不当，会出现循环调用

## 11 Spring中的编程思想总结

- OOP（面向对象编程）：封装、继承、多态
- BOP（面向Bean编程）：一切从Bean开始
- AOP（面向切片编程）：解耦，专人做专事
- IoC（控制反转）：转交控制权
- DI/DL（依赖注入/依赖查找）：构造方法、set方法、直接赋值